# 時間複雜度

當我們談論演算法的時間複雜度時，用 大 O 符號 (Big O notation) 來表示時間複雜度，它描述了演算法運行時間隨著輸入資料量增加而增長的趨勢。

## 常見的時間複雜度及其效率排序 (由最佳到最差)

以下是一些常見的時間複雜度類型，從最佳到最差排列：

### 1. O(1) - 常數時間 (Constant Time)

定義：無論輸入資料量多大，演算法的執行時間都保持不變。
最佳原因：這是理論上最快的時間複雜度，因為它不隨資料量而變化。
例子：訪問陣列中特定索引的元素、棧 (Stack) 的 push/pop 操作、哈希表 (Hash Map) 的查詢 (在沒有哈希衝突的情況下)。

### 2. O(logn) - 對數時間 (Logarithmic Time)

定義：執行時間隨著輸入資料量呈對數增長。通常以 2 為底 (log2n)。

最佳原因：效率非常高，因為對數函數增長非常緩慢。當 n 很大時，logn 相對於 n 來說非常小。

例子：二分搜尋 (Binary Search)。每次操作，待搜尋的資料範圍都會減半。

### 3. O(n) - 線性時間 (Linear Time)

定義：執行時間與輸入資料量成正比。

最佳原因：對於需要處理每個輸入元素至少一次的演算法來說，這是非常好的效率。

例子：遍歷一個陣列、尋找陣列中的最大值或最小值。

### 4. O(nlogn) - 線性對數時間 (Linear-Logarithmic Time)

定義：執行時間是 n 乘以 logn。

最佳原因：這是許多高效排序演算法（如合併排序 (Merge Sort)、快速排序 (Quick Sort)、堆積排序 (Heap Sort)）的最佳時間複雜度。在比較排序中，這通常被認為是理論上最佳的下限。

例子：高效的排序演算法。

### 5. O(n^2) - 平方時間 (Quadratic Time)

定義：執行時間與輸入資料量的平方成正比。

差的原因：在某些情況下可以接受，但當 n 變大時，效率會迅速下降。

例子：氣泡排序 (Bubble Sort)、選擇排序 (Selection Sort)、插入排序 (Insertion Sort)。通常涉及嵌套迴圈，每個迴圈都遍歷所有或大部分元素。

### 6. O(2^n) - 指數時間 (Exponential Time)

定義：執行時間與 2 的 n 次方成正比。

差的原因：非常差的效率。當 n 稍微大一點時，運行時間就會變得無法接受。

例子：解決一些遞迴問題（如費波那契數列 (Fibonacci sequence) 的最簡單遞迴實作）、旅行推銷員問題 (Traveling Salesman Problem) 的暴力解法。

### 7. O(n!) - 階乘時間 (Factorial Time)

定義：執行時間與 n 的階乘成正比。

最差原因：效率最差。即使 n 很小，運行時間也會爆炸式增長。

例子：生成所有可能的排列組合（如暴力破解密碼）。
