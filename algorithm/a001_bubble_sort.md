# Bubble Sort

氣泡排序是我第一個學到的排序，後來也因為接觸了事件上浮，所以對"氣泡"這兩個字而特別有印象。

氣泡排序是一種簡單的排序演算法。它的基本思想是重複地遍歷要排序的數列，一次比較兩個元素，如果它們的順序不正確就把它們交換過來。這個過程會一直重複，直到沒有任何一對數字需要再交換，這就表示數列已經排好序了。由於較大的元素會像氣泡一樣"浮"到數列的末尾，因此得名"氣泡排序"。

## 運作原理

1. 比較與交換：從數列的第一對相鄰元素開始，如果它們的順序錯誤（例如，前一個比後一個大），就交換它們的位置。
2. 重複遍歷：對下一對相鄰元素執行相同的操作，直到數列的末尾。
3. 一個遍歷結束：在一次完整的遍歷後，數列中最大的 (或最小的，取決於排序方向) 元素會被放置到其最終的正確位置。
4. 減少遍歷範圍：由於每次遍歷都會將一個元素放到其最終位置，因此下一次遍歷時，我們可以減少遍歷的範圍 (即不需要再比較已經排好序的末尾元素)。
5. 重複所有步驟：重複步驟 1 到 4，直到沒有任何交換發生，表示數列已經完全排序。

### Java 實作範例

```java
public class Main {

    /**
     * 執行氣泡排序並計算比較次數。
     *
     * @param arr 待排序的整數陣列。
     * @return 氣泡排序過程中發生的總比較次數。
     */
    public static int bubbleSort(int[] arr) {
        int n = arr.length;
        int totalComparisons = 0; // 用於計算總比較次數
        boolean swapped; // 標記在一次遍歷中是否發生了交換

        // 外層迴圈：控制遍歷的輪數。
        // 每次外層迴圈會將一個最大的元素 "浮" 到正確的位置。
        for (int i = 0; i < n - 1; i++) {
            swapped = false; // 在每輪遍歷開始時，重置交換標記
            
            // 內層迴圈：進行實際的比較和交換。
            // 每次遍歷結束後，最大的元素會被放到 n-1-i 的位置。
            // 所以下一輪遍歷的範圍可以縮小。
            for (int j = 0; j < n - 1 - i; j++) {
                totalComparisons++; // 每進行一次比較就增加計數

                // 如果當前元素比下一個元素大，則交換它們。
                if (arr[j] > arr[j + 1]) {
                    // 交換 arr[j] 和 arr[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true; // 發生了交換，標記為 true
                }
            }

            // 如果在這一輪遍歷中沒有發生任何交換，
            // 說明陣列已經排序完成，可以提前結束。
            if (!swapped) {
                break;
            }
            // System.out.println("第 " + (i + 1) + " 輪排序後陣列: " + java.util.Arrays.toString(arr)); // 可選：查看每輪結果
        }
        return totalComparisons;
    }

    /**
     * 輔助方法：列印陣列內容。
     * @param arr 要列印的陣列。
     */
    public static void printArray(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + (i == arr.length - 1 ? "" : ", "));
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] data = {5, 2, 4, 1, 3};
        System.out.println("原始陣列:");
        printArray(data);

        int comparisons = bubbleSort(data);

        System.out.println("排序後的陣列:");
        printArray(data);
        System.out.println("總共進行了 " + comparisons + " 次比較才排好。");
    }
}
```

### 範例執行與步驟分析

原始陣列: [5, 2, 4, 1, 3]

第一輪 (i = 0):
內層迴圈範圍: j = 0 到 3 (n-1-i = 5-1-0 = 4)
(5, 2) -> 交換 -> [2, 5, 4, 1, 3] (1次比較)
(5, 4) -> 交換 -> [2, 4, 5, 1, 3] (1次比較)
(5, 1) -> 交換 -> [2, 4, 1, 5, 3] (1次比較)
(5, 3) -> 交換 -> [2, 4, 1, 3, 5] (1次比較)
這一輪發生了交換，繼續。
本輪比較次數: 4

第二輪 (i = 1):
內層迴圈範圍: j = 0 到 2 (n-1-i = 5-1-1 = 3)
(2, 4) -> 不交換 -> [2, 4, 1, 3, 5] (1次比較)
(4, 1) -> 交換 -> [2, 1, 4, 3, 5] (1次比較)
(4, 3) -> 交換 -> [2, 1, 3, 4, 5] (1次比較)
這一輪發生了交換，繼續。
本輪比較次數: 3

第三輪 (i = 2):
內層迴圈範圍: j = 0 到 1 (n-1-i = 5-1-2 = 2)
(2, 1) -> 交換 -> [1, 2, 3, 4, 5] (1次比較)
(2, 3) -> 不交換 -> [1, 2, 3, 4, 5] (1次比較)
這一輪發生了交換，繼續。
本輪比較次數: 2

第四輪 (i = 3):
內層迴圈範圍: j = 0 到 0 (n-1-i = 5-1-3 = 1)
(1, 2) -> 不交換 -> [1, 2, 3, 4, 5] (1次比較)
這一輪沒有發生交換 (swapped 為 false)，所以排序提前結束。
本輪比較次數: 1

結果
總共進行了 4 + 3 + 2 + 1 = 10 次比較才排好。

這符合了氣泡排序在最壞情況下的時間複雜度 O(n^2)。對於有 n 個元素的陣列，它大概需要進行 n(n−1)/2 次比較。  
在這個範例中，n=5，所以是 (5 x 4 )/2 = 10 次比較。
