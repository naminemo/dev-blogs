## 浮點數精確度問題

```swift
print(0.1 + 0.2)
// Prints: fasle
```

在 Swift 中，print(0.1 + 0.2 == 0.3) 這會印出 false。

### 為什會得到 false？
這是一個經典的浮點數 (Floating-Point Number) 精確度問題，在幾乎所有使用 IEEE 754 標準表示浮點數的電腦語言中都會發生，包括 Swift。

原因解釋：

1. 二進位表示限制：電腦內部儲存浮點數 (例如 Double 或 Float) 是使用二進位 (基數 2) 來表示的。就像十進位數無法精確表示 1/3 (0.333...) 一樣，許多在十進位中可以精確表示的有限小數，在二進位中卻是無限循環小數。

    - 0.1 (十進位) 在二進位中是一個無限循環小數：0.0001100110011...
    - 0.2 (十進位) 在二進位中是一個無限循環小數：0.0011001100110...
    - 0.3 (十進位) 在二進位中是一個無限循環小數：0.0100110011001...

2. 截斷和捨入：由於電腦只能用有限的位元來儲存這些無限循環小數，所以它們會被截斷或捨入到最接近的可表示值。這導致了微小的精度損失。

3. 計算誤差累積：
當你計算 0.1 + 0.2 時，電腦實際上是在計算兩個已經經過截斷和捨入的近似值。這兩個近似值相加後，結果又會再次被截斷或捨入。

因此：

- 0.1 的內部表示可能略大於或略小於真實的 0.1。
- 0.2 的內部表示可能略大於或略小於真實的 0.2。
- 0.1 + 0.2 的結果，由於這些微小的誤差累積，不等於 0.3 的精確二進位表示，即使它們在十進位看起來是相等的。



## 如何安全地比較浮點數？
由於這種精確度問題，若真要使用比較流程的話。通常的做法是比較它們之間的絕對差值是否小於一個很小的閾值 (稱為 epsilon) 。


```swift
let a = 0.1
let b = 0.2
let c = 0.3

let sum = a + b

// bad：
print(sum == c) // false

// better：
let epsilon = 0.000001 // epsilon
print(abs(sum - c) < epsilon) // true
```

但要注意的是，即使設定了閾值，當連續作運算的數字太多時，仍會發生無法預料的結果，也就是仍然會有誤差產生。

白話來說，就是 100 個微小誤差造成了 1 個大誤差。


